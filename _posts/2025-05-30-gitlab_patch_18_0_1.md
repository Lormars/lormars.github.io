---
title: Patch Analysis - Gitlab 18.0.1
date: 2025-05-30 1:00:00
categories: [Analysis, BBP]
tags: [Gitlab, authorisation]
---

In this blog, I will pick some authorization-related security patches and try to reverse engineer how it is caused. This blog would focus on Gitlab 18.0.1

# Disclaimer

I am by no means an expert in ruby/bug bounty hunting/ruby on rails/source code review. As I explore hacking, I use writing and sharing blogs as a way to reinforce my understanding. The content below reflects my best effort to grasp the vulnerability, but it may not be entirely accurate.

### Obfuscate emails in note.bodyFirstLineHtml
Commit: eaf7702da8bab8041f84d5a24742576342ba2ecc

Gitlab would obscure external emails in system notes. Let's check the patch to see what got fixed:
```diff
+  def note_first_line_html
+    text = first_line_in_markdown(object, :note, 125)
+    obfuscate_participants_emails_in_system_note(text)
+  end

```
Basically, Gitlab refactored the resolver function for `bodyFirstLineHtml` and made sure it would call `obfuscate_participants_emails_in_system_note`. Before it, the resolver would not call `obfuscate_participants_emails_in_system_note`, leading to this vulnerability.

### Need to update 2fa requirement after accepting request
Commit: dd5abda5785fd824b7056513695a3a17d7555697

This is quite a easy patch:
```diff
  def after_accept_request
+    update_two_factor_requirement

    post_create_member_hook
  end
```

If user request access and got accepted, Gitlab should update 2fa requirement for that user, but in the past it did not.

### Unauthorized access to job data via a GraphQL query
Commit: 95cf66aa590556b28884371332175a28c8a934fd

This is actually an interesting bug, though its severity is only Low. Let's see the patch first:
```diff
-      field :trace, Types::Ci::JobTraceType, null: true,
-        description: 'Trace generated by the job.'
```
The patch simply removed `trace` field from `JobType` class. The reason is that `JobClass` actually implements `JobInterface`, and `JobInterface` already have `trace` field. 

Wait wait, why is this a vulnerability? This is because of the design architecture of Gitlab's graphql. Basically, Gitlab's interface would have a default authorization check. And if the class implements the interface does not redefine the field in the interface, then it would use the authorization check in the interface. On the other hand, if the class implementing the interface redefines the field, then it would overwrite the authorization check in the interface.

Here `JobType` redefined `trace`, leading to this vulnerability.

### Hidden/masked variables may get exposed in the UI
Commit: 75c84787120ca99c5e385d566207a1b1e5aa3bd1

According to the patch description, an attacker can reveal hidden CI variables by simply creating their own variable. Let's check the patch:
```diff
module Ci  
  class BasicVariableEntity < Grape::Entity  
    expose :id  
    expose :key  
-   expose :value
+    expose :value do |variable, _options|  
+      if variable.respond_to?(:hidden)  
+        ::Ci::VariableValue.new(variable).evaluate  
+      else  
+        variable.value  
+      end  
+    end    expose :description  
    expose :variable_type  
  
    expose :protected?, as: :protected  
    expose :masked?, as: :masked  
    expose :raw?, as: :raw  
  end  
end
```

The patch added the check to make sure that hidden variables would not be returned via API. Before, it would simply return all variables. But what makes this vulnerability interesting is the threat model it manifests.

Gitlab's access control model is primarily role based. Here, this vulnerability is partially caused by the fact that hidden variable does not follow this role based access control model. Basically, even if you are a Maintainer, you cannot view hidden variables created by other users. This is vastly different from Gitlab's access control model, leading to this vulnerability.

I have a gut feeling that Gitlab may also have other similar problems. Need to pay attention when the access control of some data does not follow role based access control. There may be a bug there.

### Improper XPath validation allows modified SAML response to bypass 2FA requirement
Commit: c641624daf734ee6f61adac4a0cc898b894590af

Actually I do not know Gitlab's 2FA requirement when users login with SSO enough to understand the threat model and how the attack works. But based on the patch, we can still learn something:

```diff
         def authn_context
           response_object = auth_hash.extra[:response_object]
-          return if response_object.blank?
+          return unless response_object.is_a?(OneLogin::RubySaml::Response)

-          document = response_object.decrypted_document
-          document ||= response_object.document
-          return if document.blank?
-
-          extract_authn_context(document)
+          response_object.authn_context_class_ref
         end
         
-        def extract_authn_context(document)
-          REXML::XPath.first(document, "//*[name()='saml:AuthnStatement' or name()='saml2:AuthnStatement' or name()='AuthnStatement']/*[name()='saml:AuthnContext' or name()='saml2:AuthnContext' or name()='AuthnContext']/*[name()='saml:AuthnContextClassRef' or name()='saml2:AuthnContextClassRef' or name()='AuthnContextClassRef']/text()").to_s
-        end
```

Based on the patch, we can see that Gitlab was using custom `XPath` to find the `authn_context`. After the patch, it is using the `OneLogin` gem to do the task.

This highlights a common security anti-pattern: reimplementing logic that is already provided by a well-maintained library. Custom parsing or logic, especially for complex protocols like SAML, can lead to subtle bugs or missed edge cases. Whenever possible, it's safer and more robust to rely on the library's implementationâ€”it's more likely to be correct, well-tested, and updated with security fixes over time.

That's it! See you next time!
